#!/usr/bin/env python3
#-*- coding: utf-8 -*-
#
# A Framework for Testing Complex Narrative Systems
# Copyright (C) 2025 Peter J. Marko
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# Filename: scripts/workflows/assembly_logic/4_extract_assembly_logic_text.py

"""
Extracts and assembles assembly logic text from raw Solar Fire reports.

This utility script is a key part of the assembly logic validation workflow.
It takes the raw, multi-section interpretation reports generated by Solar Fire
and programmatically extracts only the specific delineation components used by
our main assembly algorithm.

It correctly parses the complex file format, isolates the required text
snippets, and assembles them into the final, clean, tab-delimited
`personalities_db.gold_standard.txt` file, which serves as the "ground truth"
for our automated `pytest` verification.
"""

import argparse
import csv
import logging
import sys
from pathlib import Path

from colorama import Fore
from tqdm import tqdm

# Add project root to Python path to find src module
import sys
project_root = Path(__file__).resolve().parents[3]
sys.path.insert(0, str(project_root))

# Import the base58 decoder
from src.id_encoder import from_base58


logging.basicConfig(level=logging.INFO, format="%(message)s")


import re

def extract_subject_info(content):
    """Extracts the subject's name and birth year from the report header."""
    name_match = re.search(r"(.+?) - Natal Chart", content)
    name = name_match.group(1).strip() if name_match else "Unknown"
    year_match = re.search(r"\b(\d{4})\b", content)
    birth_year = year_match.group(1) if year_match else "Unknown"
    return name, birth_year


import shutil

def main():
    """Main function to extract and assemble the assembly logic text."""
    parser = argparse.ArgumentParser(
        description="Extract and assemble assembly logic delineations."
    )
    parser.add_argument(
        "--create-test-fixtures", 
        action="store_true",
        help="Create test fixture files from SF reports for test subjects"
    )
    args = parser.parse_args()

    # Test fixtures mode
    if args.create_test_fixtures:
        print(f"\n{Fore.YELLOW}--- Creating Test Fixtures ---{Fore.RESET}")
        sandbox_dir = Path("temp_test_environment/layer3_sandbox")
        if not sandbox_dir.exists():
            logging.error(f"Test sandbox not found: {sandbox_dir}")
            sys.exit(1)
        raw_reports_dir = sandbox_dir / "data/sf_reports_test_subjects"
        subject_db_path = None  # No subject DB in test mode
        output_path = sandbox_dir / "test_fixtures/expected_personalities_db.txt"
        output_path.parent.mkdir(parents=True, exist_ok=True)
    else:
        # Original mode
        print(f"\n{Fore.YELLOW}--- Assembling Assembly Logic Delineations ---{Fore.RESET}")
        sandbox_dir = Path("temp_assembly_logic_validation")
        if not sandbox_dir.exists():
            logging.error(f"Sandbox directory not found at '{sandbox_dir}'. Please run the previous scripts first.")
            sys.exit(1)
        raw_reports_dir = sandbox_dir / "data/intermediate/assembly_logic_raw_reports"
        subject_db_path = sandbox_dir / "data/processed/subject_db.assembly_logic.csv"
        output_path = sandbox_dir / "personalities_db.assembly_logic.txt"
    if not raw_reports_dir.exists():
        logging.error(f"Raw reports directory not found: {raw_reports_dir}")
        sys.exit(1)

    # --- Load subject DB (only in original mode) ---
    if subject_db_path:
        try:
            with open(subject_db_path, "r", encoding="utf-8") as f:
                subject_info_map = {
                    row["Name"]: {"Index": row["Index"], "idADB": row["idADB"]}
                    for row in csv.DictReader(f)
                }
        except FileNotFoundError:
            logging.error(f"Assembly logic subject DB not found at: {subject_db_path}")
            sys.exit(1)
    else:
        subject_info_map = None

    report_files = list(raw_reports_dir.glob("*.txt"))
    print(f"Processing {len(report_files)} raw report files from '{raw_reports_dir}'...")
    final_records = []
    for i, report_file in enumerate(tqdm(sorted(report_files), desc="Extracting Text", ncols=80), 1):
        content = report_file.read_text(encoding="utf-8", errors="ignore")
        name, birth_year = extract_subject_info(content)

        # Handle subject info differently based on mode
        if subject_info_map:  # Original mode
            if name not in subject_info_map:
                logging.warning(f"Could not find '{name}' in the assembly logic subject DB. Skipping.")
                continue
            subject_info = subject_info_map[name]
        else:  # Test fixtures mode - extract TimeZoneAbbr and decode to idADB
            # Extract 3-character timezone code from chart details line
            timezone_match = re.search(r'(\w{3})\s+[+-]\d+:\d+', content)
            
            if timezone_match:
                timezone_abbr = timezone_match.group(1)
                # Decode TimeZoneAbbr using base58 to get idADB
                decoded_idadb = str(from_base58(timezone_abbr))
            else:
                decoded_idadb = f"TEST{i:03d}"
            
            subject_info = {"Index": str(i), "idADB": decoded_idadb}

        # --- Extract relevant sections using a simple line-by-line parser ---
        lines = content.splitlines()
        desc_parts = []
        capturing = False
        
        headers_to_capture = [
            "BALANCE OF SIGNS", "BALANCE OF ELEMENTS", "BALANCE OF MODES",
            "BALANCE OF QUADRANTS", "BALANCE OF HEMISPHERES", "CHART POINTS"
        ]
        headers_to_stop_at = ["LUNAR PHASE", "CHART DETAILS", "BACKGROUND INFORMATION"]

        for line in lines:
            stripped_line = line.strip()

            if any(header in stripped_line for header in headers_to_stop_at + headers_to_capture):
                capturing = stripped_line in headers_to_capture

            elif capturing and stripped_line:
                # Ignore irrelevant lines within the sections
                if stripped_line.startswith("Scores:") or stripped_line.isupper():
                    continue
                desc_parts.append(stripped_line)

        full_desc = " ".join(desc_parts).strip()
        
        full_desc = " ".join(desc_parts).strip()
        final_records.append({
            "Index": subject_info["Index"],
            "idADB": subject_info["idADB"],
            "Name": name,
            "BirthYear": birth_year,
            "DescriptionText": full_desc,
        })
        
    # Sort the final records by Index to ensure a consistent order
    final_records.sort(key=lambda x: int(x["Index"]))

    # --- Write the final output file ---
    try:
        with open(output_path, "w", encoding="utf-8", newline="") as f:
            writer = csv.DictWriter(
                f,
                fieldnames=["Index", "idADB", "Name", "BirthYear", "DescriptionText"],
                delimiter="\t",
                quoting=csv.QUOTE_ALL,
            )
            writer.writeheader()
            writer.writerows(final_records)
        print(f"\n{Fore.YELLOW}--- Final Output ---{Fore.RESET}")
        print(f"{Fore.CYAN} - Assembly logic database saved to: {output_path}{Fore.RESET}")
        key_metric = f"Processed {len(final_records)} subjects"
        print(
            f"\n{Fore.GREEN}SUCCESS: {key_metric}. Assembly logic database "
            f"created successfully.{Fore.RESET}\n"
        )
    except IOError as e:
        logging.error(f"Failed to write output file: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()

# === End of scripts/workflows/assembly_logic/4_extract_assembly_logic_text.py ===
