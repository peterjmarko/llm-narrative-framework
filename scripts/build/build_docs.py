#!/usr/bin/env python3
#-*- coding: utf-8 -*-
#
# Personality Matching Experiment Framework
# Copyright (C) 2025 Peter J. Marko
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# Filename: scripts/build/build_docs.py

"""
Builds all project documentation from source templates and diagrams.

This script is the central engine for generating the project's documentation.
It processes `.template.md` files, handling custom placeholders, rendering
diagrams, and outputting final `.md` and `.docx` files for each template.

Key Features:
-   **Template Processing**: Parses `{{diagram:...}}`, `{{grouped_figure:...}}`,
    `{{include:...}}`, and `{{toc}}` placeholders within template files.

-   **Automated Table of Contents**: Automatically generates and injects a
    Table of Contents wherever a `{{toc}}` placeholder is found, ensuring it
    is always synchronized with the document's headers.

-   **Diagram Rendering**:
    -   Renders Mermaid (`.mmd`) diagrams to PNG using the local `mmdc` CLI.
    -   Renders text-based (`.txt`) diagrams to PNG using the Pillow library.

-   **Intelligent Caching**: Skips regenerating diagrams (`.png`) and documents
    (`.md`, `.docx`) if their source files have not changed, significantly
    speeding up subsequent builds.

-   **Granular Force Rebuilds**: Provides flags to selectively override the cache:
    -   `--force`: Regenerates all diagrams and documents.
    -   `--force-diagrams`: Regenerates only diagrams.
    -   `--force-documents`: Regenerates only the final `.md` and `.docx` files.

-   **Pre-commit Hook Integration**: Includes a `--check` mode that performs a
    read-only verification to ensure documentation is up-to-date without
    modifying files, ideal for CI/CD pipelines.

-   **Dual-Syntax Generation**: Uses the `.template.md` file as a single source to generate
    two different outputs for maximum compatibility:
    1.  **For `.md` viewers**: An `.md` file with HTML figures for web rendering.
    2.  **For `.docx` conversion**: In-memory content with Pandoc-native figure syntax for correct rendering in Word.

-   **Resilient DOCX Conversion**: When converting to `.docx` via Pandoc, it
    includes a retry loop that waits for locked files (e.g., open in Word)
    to be closed instead of failing immediately.

-   **DOCX Post-Processing**: Calls a helper script (`docx_postprocessor.py`)
    to reliably insert page breaks into the final `.docx` files.

Usage:
    # Standard build (uses cache)
    pdm run build-docs

    # Force a full rebuild of all diagrams and documents
    pdm run build-docs --force

    # Force regeneration of only diagrams
    pdm run build-docs --force-diagrams
"""

import os
import re
import shutil
import subprocess
import sys
import argparse
import time
import pathlib
import stat
import unicodedata
import tempfile
import contextlib
import tempfile

# Add the script's own directory ('src') to the Python path.
# This ensures that sibling modules (like docx_postprocessor) can be imported
# when this script is run from the project root.
# Add the script's directory to the Python path to ensure local imports work
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)

import docx_postprocessor # Import for post-processing DOCX files

# ANSI color codes for better terminal output
def generate_warning_header(target_filename, template_filename):
    """Generates the standard 'do not edit' warning header."""
    header = f"""<!--
================================================================================
!!! DO NOT EDIT '{target_filename}' DIRECTLY !!!

This file is automatically generated from the template:
{template_filename}

To make changes, please edit the template file and then run 'pdm run build-docs'.
================================================================================
-->"""
    return header

class Colors:
    RED = '\033[91m'      # Bright Red
    GREEN = '\033[92m'    # Bright Green
    YELLOW = '\033[93m'   # Yellow
    CYAN = '\033[96m'     # Bright Cyan
    RESET = '\033[0m'     # Resets the color to default
    BOLD = '\033[1m'      # Bold text


def make_writable(file_path):
    """Sets a file's permissions to be writable by the owner."""
    if os.path.exists(file_path):
        os.chmod(file_path, stat.S_IWRITE | stat.S_IREAD)

def make_readonly(file_path):
    """Sets a file's permissions to be read-only for all users."""
    if os.path.exists(file_path):
        os.chmod(file_path, stat.S_IREAD | stat.S_IRGRP | stat.S_IROTH)


def render_mermaid_diagram(source_path, output_path, project_root, scale='1.8'):
    """Renders a .md file to a .png using the local mmdc CLI."""
    mmdc_executable = os.path.join(project_root, 'node_modules', '.bin', 'mmdc')
    if sys.platform == "win32":
        mmdc_executable += ".cmd"

    filename = os.path.basename(source_path)
    if not os.path.exists(mmdc_executable):
        print(f"    - {Colors.RED}ERROR: Local Mermaid CLI not found. Did you run 'npm install'?{Colors.RESET}")
        return False
    
    print(f"    - Rendering Mermaid diagram: {Colors.CYAN}{filename}{Colors.RESET}")
    try:
        config_path = os.path.join(project_root, 'docs', 'mermaid-config.json')
        puppeteer_config_path = os.path.join(project_root, 'docs', 'puppeteer-config.json')

        subprocess.run(
            [mmdc_executable, '-i', source_path, '-o', output_path, '-c', config_path, '-p', puppeteer_config_path, '--scale', str(scale)],
            check=True, capture_output=True, text=True, encoding='utf-8'
        )
        return True
    except subprocess.CalledProcessError as e:
        print(f"    - {Colors.RED}ERROR: mmdc command failed for {Colors.CYAN}{filename}{Colors.RESET}.")
        if e.stderr: print(f"{Colors.YELLOW}      STDERR from mmdc:\n---\n{e.stderr.strip()}\n---{Colors.RESET}")
        return False

def render_text_diagram(source_path, output_path, project_root, font_size=36):
    """Renders a .txt file to a .png using Pillow with a specified font size."""
    filename = os.path.basename(source_path)
    print(f"    - Rendering Text diagram: {Colors.CYAN}{filename}{Colors.RESET} with font size {font_size}...")
    try:
        from PIL import Image, ImageDraw, ImageFont
    except ImportError:
        print(f"    - {Colors.RED}ERROR: 'Pillow' is not installed in the PDM environment.{Colors.RESET}")
        return False

    padding, line_spacing = 20, 4
    # The font_size is now passed in as an argument.

    font = None
    font_paths = ["Consolas", "cour.ttf", "Courier New", "Menlo", "DejaVu Sans Mono"]
    for font_path in font_paths:
        try:
            font = ImageFont.truetype(font_path, font_size)
            break
        except IOError:
            continue
    if not font: font = ImageFont.load_default()

    with open(source_path, 'r', encoding='utf-8') as f: lines = f.read().splitlines()
    if not lines: return False
    
    bbox = font.getbbox("M")
    char_width, char_height = bbox[2] - bbox[0], bbox[3] - bbox[1]
    img_width = int(max(len(line) for line in lines) * char_width) + (padding * 2)
    img_height = int(len(lines) * (char_height + line_spacing)) + (padding * 2)

    image = Image.new("RGBA", (img_width, img_height), (255, 255, 255, 0))
    draw = ImageDraw.Draw(image)
    y = padding
    for line in lines:
        draw.text((padding, y), line, font=font, fill=(0, 0, 0, 255))
        y += char_height + line_spacing
    
    image.save(output_path, "PNG")
    return True

def check_diagrams_are_up_to_date(project_root, template_files):
    """
    Performs a read-only check to see if diagram images are up-to-date.
    Returns True if all diagrams are current, False otherwise.
    """
    content_to_scan = ""
    for file_rel_path in template_files:
        full_path = os.path.join(project_root, file_rel_path)
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                content_to_scan += f.read() + "\n"
        except FileNotFoundError:
            print(f"    - {Colors.YELLOW}WARNING: Template file for diagram check not found: {full_path}{Colors.RESET}")

    all_up_to_date = True
    # Regex to find any placeholder that points to a source file for a diagram/image.
    placeholder_regex = r'\{\{(?:diagram|grouped_figure):(.+?)(?:\||\})'
    for match in re.finditer(placeholder_regex, content_to_scan):
        # The source path is the first part of the spec, before any '|'
        diagram_spec = match.group(1).strip()
        diagram_source_rel_path = diagram_spec.split('|')[0].strip()

        base_name = os.path.splitext(os.path.basename(diagram_source_rel_path))[0]
        image_rel_path = os.path.join('docs', 'images', f"{base_name}.png")
        
        source_abs_path = os.path.join(project_root, diagram_source_rel_path)
        image_abs_path = os.path.join(project_root, image_rel_path)

        if not os.path.exists(image_abs_path):
            print(f"    - {Colors.RED}MISSING:{Colors.RESET} {image_rel_path} (source: {diagram_source_rel_path})")
            all_up_to_date = False
            continue

        try:
            source_mtime = os.path.getmtime(source_abs_path)
            image_mtime = os.path.getmtime(image_abs_path)
            if source_mtime > image_mtime:
                print(f"    - {Colors.RED}OUTDATED:{Colors.RESET} {image_rel_path} (source: {diagram_source_rel_path})")
                all_up_to_date = False
        except FileNotFoundError:
             print(f"    - {Colors.YELLOW}WARNING: Source file not found for check: {diagram_source_rel_path}.{Colors.RESET}")
             all_up_to_date = False
    
    return all_up_to_date

def generate_toc(content):
    """Generates a Markdown Table of Contents from the headers in the content."""
    toc = []
    headers = re.findall(r'^(##+)\s+(.*)', content, re.MULTILINE)
    
    for level_str, title in headers:
        level = len(level_str) - 1 # h2 is level 1, h3 is level 2, etc.
        indent = "  " * (level - 1)
        
        # Create a URL-friendly anchor link
        slug = title.lower()
        slug = unicodedata.normalize('NFKD', slug).encode('ascii', 'ignore').decode('ascii')
        slug = re.sub(r'[^\w\s-]', '', slug).strip()
        slug = re.sub(r'[\s]+', '-', slug)
        
        toc.append(f"{indent}- [{title}](#{slug})")
        
    return "\n".join(toc)

def _get_diagram_paths(diagram_source_rel_path, template_path_str, project_root):
    """Calculates the correct relative paths for viewer and pandoc flavors."""
    base_name = os.path.splitext(os.path.basename(diagram_source_rel_path))[0]
    image_abs_path = os.path.join(project_root, 'docs', 'images', f"{base_name}.png")

    # For Pandoc, use an absolute file URI for maximum robustness.
    pandoc_image_path = pathlib.Path(image_abs_path).as_uri()

    # Viewer path is relative to the final generated Markdown file's location.
    final_md_path = pathlib.Path(str(template_path_str).replace('.template.md', '.md'))
    final_md_dir = final_md_path.parent
    viewer_image_path = os.path.relpath(image_abs_path, final_md_dir).replace(os.path.sep, '/')
    
    return viewer_image_path, pandoc_image_path

def process_markdown_content(content, project_root, template_path_str, flavor='viewer'):
    """
    Processes a string of markdown content, replacing custom placeholders for
    diagrams, figures, includes, page breaks, and table of contents.
    """
    # --- Function to render a single diagram's Markdown or return raw path/attrs ---
    # This will be called both by the main re.sub for {{diagram:}} and internally by {{grouped_figure:}}
    def _render_single_diagram(diagram_source_rel_path, attributes_str, current_flavor, raw_pandoc_info_only=False):
        viewer_image_path, pandoc_image_path = _get_diagram_paths(diagram_source_rel_path, template_path_str, project_root)

        attr_dict = {}
        if attributes_str:
            pairs = [p.strip() for p in attributes_str.split('|')]
            for pair in pairs:
                if '=' in pair:
                    key, value = pair.split('=', 1)
                    attr_dict[key.strip().lower()] = value.strip()

        pandoc_attr_parts = [f'{k}="{v}"' for k, v in attr_dict.items() if k != 'scale']
        # Prepend the class for centering directly into the attributes block
        pandoc_attributes_string = "{.CenteredImage " + " ".join(pandoc_attr_parts) + "}"

        if raw_pandoc_info_only:
            return pandoc_image_path, pandoc_attributes_string

        if current_flavor == 'pandoc':
            # Apply the attributes directly to the image element
            return f"![]({pandoc_image_path}){pandoc_attributes_string}"
        else: # 'viewer' flavor
            html_attrs_parts = [f'{k}="{v}"' for k, v in attr_dict.items() if k != 'scale']
            html_attrs = " ".join(html_attrs_parts)
            return f'<div align="center">\n  <img src="{viewer_image_path}" {html_attrs.strip()}>\n</div>'

    # --- Process {{grouped_figure:...}} placeholders FIRST ---
    # {{grouped_figure:diagram_path|attr1=val1|caption=Caption Text}}
    def replace_grouped_figure_placeholder(match):
        current_flavor = flavor # Use the outer 'flavor'
        full_spec = match.group(1).strip()
        
        # Split by the first ' | caption=' to separate diagram_info from actual caption
        diagram_info_part, *caption_part_list = re.split(r'\s*\|\s*caption=', full_spec, 1)

        # Parse diagram info and attributes
        diagram_parts = [p.strip() for p in diagram_info_part.split('|')]
        diagram_source_rel_path = diagram_parts[0]
        
        attr_dict = {}
        for part in diagram_parts[1:]:
            if '=' in part:
                key, value = part.split('=', 1)
                attr_dict[key.strip().lower()] = value.strip()
        
        caption_text = caption_part_list[0] if caption_part_list else ""

        # Render the nested diagram using the helper function to get raw path and attributes.
        diagram_specific_attrs = '|'.join([f'{k}={v}' for k, v in attr_dict.items() if k not in ['caption']])
        
        # Call _render_single_diagram with the new flag to get path and attributes string.
        # The helper function now correctly includes the .CenteredImage class.
        diagram_image_path, diagram_attributes_string = _render_single_diagram(diagram_source_rel_path, diagram_specific_attrs, current_flavor='pandoc', raw_pandoc_info_only=True)

        if current_flavor == 'pandoc':
            # For DOCX, use Pandoc's native figure syntax with the attributes applied directly.
            return f"![{caption_text}]({diagram_image_path}){diagram_attributes_string}"
        else: # viewer flavor
            # For MD viewers, render as an HTML block for center alignment and clarity.
            html_attrs_parts = [f'{k}="{v}"' for k, v in attr_dict.items() if k not in ['scale', 'caption']]
            html_attrs = " ".join(html_attrs_parts)
            
            clean_caption = re.sub(r'^\s*#+\s*', '', caption_text, flags=re.MULTILINE)
            viewer_image_path, _ = _get_diagram_paths(diagram_source_rel_path, template_path_str, project_root)

            return f'<div align="center">\n  <p>{clean_caption}</p>\n  <img src="{viewer_image_path}" {html_attrs.strip()}>\n</div>'

    # Process grouped_figure FIRST to ensure its internal diagram is handled before main diagram re.sub
    content = re.sub(r'\{\{grouped_figure:(.*?)\}\}', 
                     replace_grouped_figure_placeholder, 
                     content, flags=re.DOTALL) # Ensure DOTALL is here

    # --- Process standalone {{diagram:...}} placeholders ---
    # These will only be processed if they are NOT inside a {{grouped_figure}}
    def replace_standalone_diagram_placeholder(match):
        return _render_single_diagram(match.group(1), match.group(2) or "", flavor)

    content = re.sub(r'\{\{diagram:(.*?)(?:\|(.*?))?\}\}', 
                     replace_standalone_diagram_placeholder, 
                     content)

    # --- Process {{include:...}} placeholders ---
    def replace_include_placeholder(match):
        include_rel_path = match.group(1)
        include_abs_path = os.path.join(project_root, include_rel_path)
        try:
            with open(include_abs_path, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError:
            return f"ERROR: Included file not found at '{include_rel_path}'"
            
    content = re.sub(r'\{\{include:(.*?)\}\}', replace_include_placeholder, content)

    # --- Process {{pagebreak}} placeholders ---
    # This generates a unique marker that can be found and replaced by a post-processor.
    def replace_pagebreak_placeholder(match):
        if flavor == 'pandoc':
            return '\n---PAGEBREAK---\n' # Unique marker for post-processing
        else:
            return ''

    content = re.sub(r'\{\{pagebreak\}\}', replace_pagebreak_placeholder, content)

    # --- Process {{toc}} placeholder ---
    if '{{toc}}' in content:
        toc_content = generate_toc(content)
        content = content.replace('{{toc}}', toc_content, 1)

    return content

def build_doc_content(project_root, template_path_str, flavor='viewer'):
    """
    Builds the content for a specific doc by processing its template.
    """
    with open(template_path_str, 'r', encoding='utf-8') as f:
        content = f.read()
    return process_markdown_content(content, project_root, template_path_str, flavor)

def render_all_diagrams(project_root, force_render=False, template_files=None):
    """
    Scans all specified template files for diagram placeholders, then renders
    or copies them as needed. Returns True on success.
    """
    if template_files is None:
        template_files = ['docs/FRAMEWORK_MANUAL.template.md']

    print(f"\n{Colors.BOLD}{Colors.CYAN}--- Processing Diagrams ---{Colors.RESET}")
    
    content_to_scan = ""
    for file_rel_path in template_files:
        # Resolve the full path to handle files in the root vs. subdirectories correctly.
        full_path = os.path.join(project_root, file_rel_path)
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                content_to_scan += f.read() + "\n"
        except FileNotFoundError:
            # Print the full path that was attempted for clear debugging.
            print(f"    - {Colors.YELLOW}WARNING: Template file for diagram scan not found: {full_path}{Colors.RESET}")

    content = content_to_scan
    images_dir = os.path.join(project_root, 'docs', 'images')
    os.makedirs(images_dir, exist_ok=True)
    
    diagrams_to_render = set() # Store (source_path, attributes_str) tuples to avoid duplicates

    # Find standalone {{diagram:...}} placeholders
    for placeholder in re.finditer(r'\{\{diagram:(.*?)(?:\|(.*?))?\}\}', content):
        diagram_source_rel_path = placeholder.group(1).strip()
        attributes_str = placeholder.group(2) or ""
        diagrams_to_render.add((diagram_source_rel_path, attributes_str))

    # Find diagrams inside {{grouped_figure:...}} placeholders
    # Need to parse the full spec to extract the diagram_source_rel_path and its attributes
    for placeholder in re.finditer(r'\{\{grouped_figure:(.*?)\}\}', content, flags=re.DOTALL):
        full_spec = placeholder.group(1).strip()
        
        # This parsing logic reuses the attribute extraction from build_readme_content
        diagram_info_part, *caption_part_list = re.split(r'\s*\|\s*caption=', full_spec, 1)
        diagram_parts = [p.strip() for p in diagram_info_part.split('|')]
        diagram_source_rel_path = diagram_parts[0]
        
        # Reconstruct attributes string from diagram_parts[1:] for rendering purposes
        attr_dict = {}
        for part in diagram_parts[1:]:
            if '=' in part:
                key, value = part.split('=', 1)
                attr_dict[key.strip().lower()] = value.strip()
        reconstructed_attributes_str = '|'.join([f'{k}={v}' for k,v in attr_dict.items()])

        diagrams_to_render.add((diagram_source_rel_path, reconstructed_attributes_str))
        
    all_diagrams_ok = True
    for diagram_source_rel_path, attributes_str in diagrams_to_render:
        base_name = os.path.splitext(os.path.basename(diagram_source_rel_path))[0]
        image_abs_path = os.path.join(project_root, 'docs', 'images', f"{base_name}.png")
        source_abs_path = os.path.join(project_root, diagram_source_rel_path)
        
        should_render = False
        if force_render:
            should_render = True
        elif not os.path.exists(image_abs_path):
            should_render = True
        else:
            try:
                source_mtime = os.path.getmtime(source_abs_path)
                image_mtime = os.path.getmtime(image_abs_path)
                if source_mtime > image_mtime:
                    should_render = True
                else:
                    print(f"    - Skipping {Colors.CYAN}{os.path.basename(diagram_source_rel_path)}{Colors.RESET} (up-to-date)")
            except FileNotFoundError:
                print(f"    - {Colors.YELLOW}WARNING: Source file not found for comparison: {diagram_source_rel_path}. Will attempt to render.{Colors.RESET}")
                # If source is missing, we must render or it'll fail later.
                should_render = True 

        if should_render:
            if diagram_source_rel_path.endswith('.mmd'):
                scale_match = re.search(r'scale=([\d\.]+)', attributes_str)
                scale = scale_match.group(1) if scale_match else '1.8'
                if not render_mermaid_diagram(source_abs_path, image_abs_path, project_root, scale=scale):
                    all_diagrams_ok = False
            elif diagram_source_rel_path.endswith('.txt'):
                font_size = 22 if 'replication_report_format' in diagram_source_rel_path else 20 if 'analysis_log_format' in diagram_source_rel_path else 36
                if not render_text_diagram(source_abs_path, image_abs_path, project_root, font_size=font_size):
                    all_diagrams_ok = False
            elif diagram_source_rel_path.endswith(('.png', '.jpg', '.jpeg')):
                print(f"    - Copying pre-generated image: {Colors.CYAN}{os.path.basename(diagram_source_rel_path)}{Colors.RESET}")
                try:
                    shutil.copy2(source_abs_path, image_abs_path) # copy2 preserves metadata like mtime
                except FileNotFoundError:
                    print(f"    - {Colors.RED}ERROR: Source image not found at {source_abs_path}{Colors.RESET}")
                    all_diagrams_ok = False
                except Exception as e:
                    print(f"    - {Colors.RED}ERROR: Failed to copy {os.path.basename(diagram_source_rel_path)}: {e}{Colors.RESET}")
                    all_diagrams_ok = False
            else:
                print(f"    - {Colors.YELLOW}WARNING: Unknown diagram type for {Colors.CYAN}{os.path.basename(diagram_source_rel_path)}{Colors.RESET}. Skipping processing.{Colors.RESET}")
    
    if not all_diagrams_ok:
        print(f"\n{Colors.RED}{Colors.BOLD}--- BUILD FAILED: One or more diagrams could not be rendered. ---{Colors.RESET}")
    
    return all_diagrams_ok

def convert_to_docx(pypandoc, output_docx_path, project_root, source_md_path):
    """Converts a markdown file to DOCX, with robust error handling."""
    output_filename = os.path.basename(output_docx_path)
    print(f"    - Converting '{Colors.CYAN}{os.path.basename(source_md_path)}{Colors.RESET}' to DOCX...")
    
    permission_error_printed = False
    while True:
        try:
            pandoc_args_base = ['--standalone']
            reference_docx_path = os.path.join(project_root, 'docs', 'custom_reference.docx')
            if os.path.exists(reference_docx_path):
                pandoc_args_base.append(f'--reference-doc={reference_docx_path}')

            input_format_with_extensions = 'markdown+yaml_metadata_block+latex_macros+raw_attribute'
            final_pandoc_extra_args = ['-f', input_format_with_extensions] + pandoc_args_base
            
            pypandoc.convert_file(
                source_md_path, 'docx', format='markdown',
                outputfile=output_docx_path,
                extra_args=final_pandoc_extra_args
            )
            
            if permission_error_printed:
                print(f"      {Colors.GREEN}File unlocked. Resuming...{Colors.RESET}")
            
            print(f"      {Colors.GREEN}Successfully built '{Colors.CYAN}{output_filename}{Colors.GREEN}'!{Colors.RESET}")

            docx_postprocessor.insert_page_breaks_by_marker(output_docx_path, '---PAGEBREAK---')
            return True

        except RuntimeError as e:
            if "permission denied" in str(e).lower():
                if not permission_error_printed:
                    print(f"      {Colors.YELLOW}[WAITING] Could not write to '{output_filename}'.")
                    print(f"      The file is likely open in another program.")
                    print(f"      Please close the file. The script will retry automatically... (Ctrl+C to cancel){Colors.RESET}")
                    permission_error_printed = True
                time.sleep(2)
                continue
            else:
                print(f"\n{Colors.RED}[ERROR] An unexpected error occurred with Pandoc.{Colors.RESET}")
                raise e
        except FileNotFoundError:
            print(f"{Colors.RED}\n[ERROR] `pandoc` command not found. See: https://pandoc.org/installing.html{Colors.RESET}")
            return False
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Build cancelled by user.{Colors.RESET}")
            return False


def is_doc_up_to_date(project_root, final_md_path_str, template_path_str):
    """Checks if a final .md file is newer than its template and all its generated diagram images."""
    if not os.path.exists(final_md_path_str) or not os.path.exists(template_path_str):
        return False
    
    try:
        final_mtime = os.path.getmtime(final_md_path_str)
        if os.path.getmtime(template_path_str) > final_mtime:
            return False

        with open(template_path_str, 'r', encoding='utf-8') as f:
            content = f.read()

        # Regex to find any placeholder that points to a source file for a diagram/image.
        placeholder_regex = r'\{\{(?:diagram|grouped_figure):(.+?)(?:\||\})'
        for match in re.finditer(placeholder_regex, content):
            source_file_rel_path = match.group(1).strip()
            base_name = os.path.splitext(os.path.basename(source_file_rel_path))[0]
            image_path = os.path.join(project_root, 'docs', 'images', f"{base_name}.png")
            
            if os.path.exists(image_path) and os.path.getmtime(image_path) > final_mtime:
                return False
        
        return True
    except (OSError, FileNotFoundError):
        return False

def main():
    parser = argparse.ArgumentParser(description="Builds project documentation from templates.")
    parser.add_argument('--check', action='store_true', help="Check if docs are up-to-date without modifying files.")
    parser.add_argument('--force', action='store_true', help="Force regeneration of all diagrams and documents.")
    parser.add_argument('--force-diagrams', action='store_true', help="Force regeneration of all diagrams.")
    parser.add_argument('--force-documents', action='store_true', help="Force regeneration of all markdown and docx documents.")
    args = parser.parse_args()
    
    project_root = pathlib.Path(__file__).resolve().parent.parent.parent
    
    # Determine which stages to force
    do_force_diagrams = args.force or args.force_diagrams
    do_force_documents = args.force or args.force_documents
    
    if args.check:
        print(f"{Colors.BOLD}{Colors.CYAN}--- Checking if documentation is up-to-date... ---{Colors.RESET}")

        docs_to_check = [
            ('README.template.md', 'README.md'),
            ('DEVELOPERS_GUIDE.template.md', 'DEVELOPERS_GUIDE.md'),
            ('data/DATA_PREPARATION_DATA_DICTIONARY.template.md', 'data/DATA_PREPARATION_DATA_DICTIONARY.md'),
            ('docs/FRAMEWORK_MANUAL.template.md', 'docs/FRAMEWORK_MANUAL.md'),
            ('docs/LIFECYCLE_GUIDE.template.md', 'docs/LIFECYCLE_GUIDE.md'),
            ('docs/PROJECT_ROADMAP.md', 'docs/PROJECT_ROADMAP.md'),
            ('docs/article_main_text.template.md', 'docs/article_main_text.md'),
            ('docs/REPLICATION_GUIDE.template.md', 'docs/REPLICATION_GUIDE.md'),
            ('docs/TESTING_GUIDE.template.md', 'docs/TESTING_GUIDE.md')
        ]
        
        # 1. Check diagrams from all templates
        all_template_paths = [item[0] for item in docs_to_check]
        diagrams_ok = check_diagrams_are_up_to_date(project_root, all_template_paths)

        # 2. Check content of final markdown files
        all_content_ok = True
        for template_rel_path, final_rel_path in docs_to_check:
            # If the source and destination are the same, it's a simple MD file, not a template.
            # Skip the content check for these files.
            if template_rel_path == final_rel_path:
                continue

            template_path = os.path.join(project_root, template_rel_path)
            final_path = os.path.join(project_root, final_rel_path)
            
            if not os.path.exists(template_path):
                continue

            # This logic must perfectly mirror the build process.
            # First, build the body content.
            viewer_content = build_doc_content(project_root, template_path, flavor='viewer')
            # Then, generate the corresponding warning header.
            header = generate_warning_header(final_rel_path, f"/{template_rel_path}")
            # The final expected content is the combination of both.
            expected_content = header + '\n' + viewer_content
            
            try:
                with open(final_path, 'r', encoding='utf-8') as f:
                    current_content = f.read()
            except FileNotFoundError:
                print(f"    - {Colors.RED}MISSING:{Colors.RESET} {final_rel_path}")
                all_content_ok = False
                continue

            # Normalize line endings for a robust comparison before the final check.
            normalized_current = current_content.replace('\r\n', '\n')
            normalized_expected = expected_content.replace('\r\n', '\n')

            if normalized_current != normalized_expected:
                print(f"    - {Colors.RED}OUTDATED:{Colors.RESET} {final_rel_path} content does not match template.")
                all_content_ok = False

        if diagrams_ok and all_content_ok:
            print(f"{Colors.GREEN}Documentation is up-to-date.{Colors.RESET}")
            sys.exit(0)
        else:
            print(f"\n{Colors.RED}Documentation is out of date. Please run 'pdm run build-docs' and commit the changes.{Colors.RESET}")
            sys.exit(1)

    # Define which files have placeholders that might contain diagrams
    files_with_diagrams = [
        'README.template.md',
        'DEVELOPERS_GUIDE.template.md',
        'data/DATA_PREPARATION_DATA_DICTIONARY.template.md',
        'docs/FRAMEWORK_MANUAL.template.md',
        'docs/LIFECYCLE_GUIDE.template.md',
        'docs/PROJECT_ROADMAP.md',
        'docs/article_main_text.template.md',
        'docs/REPLICATION_GUIDE.template.md',
        'docs/TESTING_GUIDE.template.md'
    ]
    if not render_all_diagrams(project_root, force_render=do_force_diagrams, template_files=files_with_diagrams):
        sys.exit(1)

    print(f"\n{Colors.BOLD}{Colors.CYAN}--- Building Final Markdown Files from Templates ---{Colors.RESET}")

    # --- 1. Build README.md ---
    readme_template_path = os.path.join(project_root, 'README.template.md')
    readme_final_path = os.path.join(project_root, 'README.md')
    if not do_force_documents and is_doc_up_to_date(project_root, readme_final_path, readme_template_path):
        print(f"    - Skipping {Colors.CYAN}README.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, readme_template_path, flavor='viewer')
        header = generate_warning_header('README.md', '/README.template.md')
        final_content = header + '\n' + viewer_content
        
        make_writable(readme_final_path)
        with open(readme_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(readme_final_path)
        print(f"    - {Colors.GREEN}Successfully built README.md!{Colors.RESET}")
    
    # --- 2. Build DEVELOPERS_GUIDE.md ---
    contrib_template_path = os.path.join(project_root, 'DEVELOPERS_GUIDE.template.md')
    contrib_final_path = os.path.join(project_root, 'DEVELOPERS_GUIDE.md')
    if not do_force_documents and is_doc_up_to_date(project_root, contrib_final_path, contrib_template_path):
        print(f"    - Skipping {Colors.CYAN}DEVELOPERS_GUIDE.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, contrib_template_path, flavor='viewer')
        header = generate_warning_header('DEVELOPERS_GUIDE.md', '/DEVELOPERS_GUIDE.template.md')
        final_content = header + '\n' + viewer_content
        
        make_writable(contrib_final_path)
        with open(contrib_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(contrib_final_path)
        print(f"    - {Colors.GREEN}Successfully built DEVELOPERS_GUIDE.md!{Colors.RESET}")

    # --- 3. Build FRAMEWORK_MANUAL.md ---
    doc_template_path = os.path.join(project_root, 'docs/FRAMEWORK_MANUAL.template.md')
    doc_final_path = os.path.join(project_root, 'docs/FRAMEWORK_MANUAL.md')
    if not do_force_documents and is_doc_up_to_date(project_root, doc_final_path, doc_template_path):
        print(f"    - Skipping {Colors.CYAN}FRAMEWORK_MANUAL.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, doc_template_path, flavor='viewer')
        header = generate_warning_header('docs/FRAMEWORK_MANUAL.md', '/docs/FRAMEWORK_MANUAL.template.md')
        final_content = header + '\n' + viewer_content

        make_writable(doc_final_path)
        with open(doc_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(doc_final_path)
        print(f"    - {Colors.GREEN}Successfully built FRAMEWORK_MANUAL.md!{Colors.RESET}")

    # --- 4. Build article_main_text.md ---
    article_template_path = os.path.join(project_root, 'docs/article_main_text.template.md')
    article_final_path = os.path.join(project_root, 'docs/article_main_text.md')
    if not do_force_documents and is_doc_up_to_date(project_root, article_final_path, article_template_path):
         print(f"    - Skipping {Colors.CYAN}article_main_text.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, article_template_path, flavor='viewer')
        header = generate_warning_header('docs/article_main_text.md', '/docs/article_main_text.template.md')
        final_content = header + '\n' + viewer_content

        make_writable(article_final_path)
        with open(article_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(article_final_path)
        print(f"    - {Colors.GREEN}Successfully built article_main_text.md!{Colors.RESET}")

    # --- 5. Build REPLICATION_GUIDE.md ---
    supp_template_path = os.path.join(project_root, 'docs/REPLICATION_GUIDE.template.md')
    supp_final_path = os.path.join(project_root, 'docs/REPLICATION_GUIDE.md')
    if not do_force_documents and is_doc_up_to_date(project_root, supp_final_path, supp_template_path):
         print(f"    - Skipping {Colors.CYAN}REPLICATION_GUIDE.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, supp_template_path, flavor='viewer')
        header = generate_warning_header('docs/REPLICATION_GUIDE.md', '/docs/REPLICATION_GUIDE.template.md')
        final_content = header + '\n' + viewer_content

        make_writable(supp_final_path)
        with open(supp_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(supp_final_path)
        print(f"    - {Colors.GREEN}Successfully built REPLICATION_GUIDE.md!{Colors.RESET}")

    # --- 6. Build DATA_PREPARATION_DATA_DICTIONARY.md ---
    data_template_path = os.path.join(project_root, 'data/DATA_PREPARATION_DATA_DICTIONARY.template.md')
    data_final_path = os.path.join(project_root, 'data/DATA_PREPARATION_DATA_DICTIONARY.md')
    if not do_force_documents and is_doc_up_to_date(project_root, data_final_path, data_template_path):
         print(f"    - Skipping {Colors.CYAN}DATA_PREPARATION_DATA_DICTIONARY.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, data_template_path, flavor='viewer')
        header = generate_warning_header('data/DATA_PREPARATION_DATA_DICTIONARY.md', '/data/DATA_PREPARATION_DATA_DICTIONARY.template.md')
        final_content = header + '\n' + viewer_content

        make_writable(data_final_path)
        with open(data_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(data_final_path)
        print(f"    - {Colors.GREEN}Successfully built DATA_PREPARATION_DATA_DICTIONARY.md!{Colors.RESET}")

    # --- 7. Build LIFECYCLE_GUIDE.md ---
    lifecycle_template_path = os.path.join(project_root, 'docs/LIFECYCLE_GUIDE.template.md')
    lifecycle_final_path = os.path.join(project_root, 'docs/LIFECYCLE_GUIDE.md')
    if not do_force_documents and is_doc_up_to_date(project_root, lifecycle_final_path, lifecycle_template_path):
         print(f"    - Skipping {Colors.CYAN}LIFECYCLE_GUIDE.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, lifecycle_template_path, flavor='viewer')
        header = generate_warning_header('docs/LIFECYCLE_GUIDE.md', '/docs/LIFECYCLE_GUIDE.template.md')
        final_content = header + '\n' + viewer_content

        make_writable(lifecycle_final_path)
        with open(lifecycle_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(lifecycle_final_path)
        print(f"    - {Colors.GREEN}Successfully built LIFECYCLE_GUIDE.md!{Colors.RESET}")

    # --- 8. Build PROJECT_ROADMAP.md ---
    roadmap_template_path = os.path.join(project_root, 'docs/PROJECT_ROADMAP.md') # Note: Not a template, but needs to be in the build flow
    roadmap_final_path = os.path.join(project_root, 'docs/PROJECT_ROADMAP.md')
    if not do_force_documents and is_doc_up_to_date(project_root, roadmap_final_path, roadmap_template_path):
         print(f"    - Skipping {Colors.CYAN}PROJECT_ROADMAP.md{Colors.RESET} build (up-to-date).")
    else:
        # Since PROJECT_ROADMAP.md is not a template, we just ensure it exists for the DOCX conversion
        print(f"    - {Colors.GREEN}Verified PROJECT_ROADMAP.md exists for DOCX conversion.{Colors.RESET}")
    
    # --- 9. Build TESTING_GUIDE.md ---
    test_template_path = os.path.join(project_root, 'docs', 'TESTING_GUIDE.template.md')
    test_final_path = os.path.join(project_root, 'docs', 'TESTING_GUIDE.md')
    if not do_force_documents and is_doc_up_to_date(project_root, test_final_path, test_template_path):
         print(f"    - Skipping {Colors.CYAN}TESTING_GUIDE.md{Colors.RESET} build (up-to-date).")
    else:
        viewer_content = build_doc_content(project_root, test_template_path, flavor='viewer')
        header = generate_warning_header('docs/TESTING_GUIDE.md', '/docs/TESTING_GUIDE.template.md')
        final_content = header + '\n' + viewer_content

        make_writable(test_final_path)
        with open(test_final_path, 'w', encoding='utf-8') as f:
            f.write(final_content)
        make_readonly(test_final_path)
        print(f"    - {Colors.GREEN}Successfully built TESTING_GUIDE.md!{Colors.RESET}")

    print(f"\n{Colors.BOLD}{Colors.CYAN}--- Converting all Markdown files to DOCX ---{Colors.RESET}")
    try:
        import pypandoc
        word_docs_dir = os.path.join(project_root, 'docs', 'word_docs')
        os.makedirs(word_docs_dir, exist_ok=True)
        
        # List of final markdown files that were built from templates.
        # These need special handling for DOCX conversion to use pandoc-flavored placeholders.
        files_needing_placeholders = {
            str(pathlib.Path(readme_final_path).resolve()),
            str(pathlib.Path(doc_final_path).resolve()),
            str(pathlib.Path(supp_final_path).resolve()),
            str(pathlib.Path(test_final_path).resolve()),
        }
        
        exclude_dirs = {'.git', '.venv', 'node_modules', 'docs/word_docs'}
        all_md_files = {p for p in project_root.glob('**/*.md')}
        
        # Use a context manager for robust cleanup of temporary files
        with tempfile.TemporaryDirectory() as temp_dir:
            for source_path in sorted(list(all_md_files)):
                if any(part in exclude_dirs for part in source_path.parts) or source_path.name.endswith('.template.md'):
                    continue

                output_filename = source_path.with_suffix(".docx").name
                output_path = os.path.join(word_docs_dir, output_filename)
                
                should_build = False
                if do_force_documents or not os.path.exists(output_path):
                    should_build = True
                elif os.path.getmtime(output_path) < os.path.getmtime(source_path):
                    should_build = True

                if not should_build:
                    print(f"    - Skipping DOCX conversion for {Colors.CYAN}{output_filename}{Colors.RESET} (up-to-date).")
                    continue
                
                # Check if this MD file was generated from a template
                template_path = pathlib.Path(str(source_path).replace('.md', '.template.md'))
                path_to_convert = str(source_path)

                # If a template exists, we must re-process it with pandoc flavor to ensure
                # metadata and figures are correctly formatted for DOCX conversion.
                if template_path.exists():
                    pandoc_flavored_content = build_doc_content(project_root, str(template_path), flavor='pandoc')
                    
                    # Write the processed content to a temporary file for reliable conversion.
                    temp_md_path = os.path.join(temp_dir, source_path.name)
                    with open(temp_md_path, 'w', encoding='utf-8') as f:
                        f.write(pandoc_flavored_content)
                    path_to_convert = temp_md_path
                
                if not convert_to_docx(pypandoc, output_path, project_root, source_md_path=path_to_convert):
                    sys.exit(1)
        
        print(f"\n{Colors.GREEN}{Colors.BOLD}All documents built successfully.\n{Colors.RESET}")

    except ImportError:
        print(f"{Colors.YELLOW}--- DEPENDENCY WARNING: 'pypandoc' not found. Skipping DOCX generation. ---{Colors.RESET}")

if __name__ == "__main__":
    main()

# === End of scripts/build/build_docs.py ===
