#!/usr/bin/env python3
#-*- coding: utf-8 -*-
#
# A Framework for Testing Complex Narrative Systems
# Copyright (C) 2025 Peter J. Marko
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# Filename: scripts/build/build_docs.py

"""
Builds all project documentation from source templates and diagrams.

This script is the central engine for generating the project's documentation.
It processes `.template.md` files, handling custom placeholders, rendering
diagrams, and outputting final `.md` and `.docx` files for each template.

Key Features:
-   **Template Processing**: Parses `{{diagram:...}}`, `{{grouped_figure:...}}`,
    `{{include:...}}`, and `{{toc}}` placeholders within template files.

-   **Automated Table of Contents**: Automatically generates and injects a
    Table of Contents wherever a `{{toc}}` placeholder is found, ensuring it
    is always synchronized with the document's headers.

-   **Diagram Rendering**:
    -   Renders Mermaid (`.mmd`) diagrams to PNG using the local `mmdc` CLI.
    -   Renders text-based (`.txt`) diagrams to PNG using the Pillow library.

-   **Intelligent Caching**: Skips regenerating diagrams (`.png`) and documents
    (`.md`, `.docx`) if their source files have not changed, significantly
    speeding up subsequent builds.

-   **Granular Force Rebuilds**: Provides flags to selectively override the cache:
    -   `--force`: Regenerates all diagrams and documents.
    -   `--force-diagrams`: Regenerates only diagrams.
    -   `--force-documents`: Regenerates only the final `.md` and `.docx` files.

-   **Pre-commit Hook Integration**: Includes a `--check` mode that performs a
    read-only verification to ensure documentation is up-to-date without
    modifying files, ideal for CI/CD pipelines.

-   **Dual-Syntax Generation**: Uses the `.template.md` file as a single source to generate
    two different outputs for maximum compatibility:
    1.  **For `.md` viewers**: An `.md` file with HTML figures for web rendering.
    2.  **For `.docx` conversion**: In-memory content with Pandoc-native figure syntax for correct rendering in Word.

-   **Resilient DOCX Conversion**: When converting to `.docx` via Pandoc, it
    includes a retry loop that waits for locked files (e.g., open in Word)
    to be closed instead of failing immediately.

-   **DOCX Post-Processing**: Calls a helper script (`docx_postprocessor.py`)
    to reliably insert page breaks into the final `.docx` files.

Usage:
    # Standard build (uses cache)
    pdm run build-docs

    # Force a full rebuild of all diagrams and documents
    pdm run build-docs --force

    # Force regeneration of only diagrams
    pdm run build-docs --force-diagrams
"""

import os
import re
import shutil
import subprocess
import sys
import argparse
import time
import pathlib
import stat
import unicodedata
import tempfile
import contextlib
import tempfile
from datetime import datetime

# Add the script's own directory ('src') to the Python path.
# This ensures that sibling modules (like docx_postprocessor) can be imported
# when this script is run from the project root.
# Add the script's directory to the Python path to ensure local imports work
current_dir = os.path.dirname(os.path.abspath(__file__))
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)

import docx_postprocessor # Import for post-processing DOCX files

# ANSI color codes for better terminal output
def generate_warning_header(target_filename, template_filename):
    """Generates the standard 'do not edit' warning header."""
    header = f"""<!--
================================================================================
!!! DO NOT EDIT '{target_filename}' DIRECTLY !!!

This file is automatically generated from the template:
{template_filename}

To make changes, please edit the template file and then run 'pdm run build-docs'.
================================================================================
-->"""
    return header

class Colors:
    RED = '\033[91m'      # Bright Red
    GREEN = '\033[92m'    # Bright Green
    YELLOW = '\033[93m'   # Yellow
    CYAN = '\033[96m'     # Bright Cyan
    RESET = '\033[0m'     # Resets the color to default
    BOLD = '\033[1m'      # Bold text


def make_writable(file_path):
    """Sets a file's permissions to be writable by the owner."""
    if os.path.exists(file_path):
        os.chmod(file_path, stat.S_IWRITE | stat.S_IREAD)

def make_readonly(file_path):
    """Sets a file's permissions to be read-only for all users."""
    if os.path.exists(file_path):
        os.chmod(file_path, stat.S_IREAD | stat.S_IRGRP | stat.S_IROTH)


def render_mermaid_diagram(source_path, output_path, project_root, scale='1.8'):
    """Renders a .md file to a .png using the local mmdc CLI."""
    mmdc_executable = os.path.join(project_root, 'node_modules', '.bin', 'mmdc')
    if sys.platform == "win32":
        mmdc_executable += ".cmd"

    filename = os.path.basename(source_path)
    if not os.path.exists(mmdc_executable):
        print(f"    - {Colors.RED}ERROR: Local Mermaid CLI not found. Did you run 'npm install'?{Colors.RESET}")
        return False
    
    print(f"    - Rendering Mermaid diagram: {Colors.CYAN}{filename}{Colors.RESET}")
    try:
        config_path = os.path.join(project_root, 'docs', 'mermaid-config.json')
        puppeteer_config_path = os.path.join(project_root, 'docs', 'puppeteer-config.json')

        subprocess.run(
            [mmdc_executable, '-i', source_path, '-o', output_path, '-c', config_path, '-p', puppeteer_config_path, '--scale', str(scale)],
            check=True, capture_output=True, text=True, encoding='utf-8'
        )
        return True
    except subprocess.CalledProcessError as e:
        print(f"    - {Colors.RED}ERROR: mmdc command failed for {Colors.CYAN}{filename}{Colors.RESET}.")
        if e.stderr: print(f"{Colors.YELLOW}      STDERR from mmdc:\n---\n{e.stderr.strip()}\n---{Colors.RESET}")
        return False

def render_text_diagram(source_path, output_path, project_root, font_size=36):
    """Renders a .txt file to a .png using Pillow with a specified font size."""
    filename = os.path.basename(source_path)
    print(f"    - Rendering Text diagram: {Colors.CYAN}{filename}{Colors.RESET} with font size {font_size}...")
    try:
        from PIL import Image, ImageDraw, ImageFont
    except ImportError:
        print(f"    - {Colors.RED}ERROR: 'Pillow' is not installed in the PDM environment.{Colors.RESET}")
        return False

    padding, line_spacing = 20, 4
    # The font_size is now passed in as an argument.

    font = None
    font_paths = ["Consolas", "cour.ttf", "Courier New", "Menlo", "DejaVu Sans Mono"]
    for font_path in font_paths:
        try:
            font = ImageFont.truetype(font_path, font_size)
            break
        except IOError:
            continue
    if not font: font = ImageFont.load_default()

    with open(source_path, 'r', encoding='utf-8') as f: lines = f.read().splitlines()
    if not lines: return False
    
    bbox = font.getbbox("M")
    char_width, char_height = bbox[2] - bbox[0], bbox[3] - bbox[1]
    img_width = int(max(len(line) for line in lines) * char_width) + (padding * 2)
    img_height = int(len(lines) * (char_height + line_spacing)) + (padding * 2)

    image = Image.new("RGBA", (img_width, img_height), (255, 255, 255, 0))
    draw = ImageDraw.Draw(image)
    y = padding
    for line in lines:
        draw.text((padding, y), line, font=font, fill=(0, 0, 0, 255))
        y += char_height + line_spacing
    
    image.save(output_path, "PNG")
    return True

def check_diagrams_are_up_to_date(project_root, template_files):
    """
    Performs a read-only check to see if diagram images are up-to-date.
    Returns True if all diagrams are current, False otherwise.
    """
    content_to_scan = ""
    for file_rel_path in template_files:
        full_path = os.path.join(project_root, file_rel_path)
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                content_to_scan += f.read() + "\n"
        except FileNotFoundError:
            print(f"    - {Colors.YELLOW}WARNING: Template file for diagram check not found: {full_path}{Colors.RESET}")

    all_up_to_date = True
    # Regex to find any placeholder that points to a source file for a diagram/image.
    placeholder_regex = r'\{\{(?:diagram|grouped_figure):(.+?)(?:\||\})'
    for match in re.finditer(placeholder_regex, content_to_scan):
        # The source path is the first part of the spec, before any '|'
        diagram_spec = match.group(1).strip()
        diagram_source_rel_path = diagram_spec.split('|')[0].strip()

        base_name = os.path.splitext(os.path.basename(diagram_source_rel_path))[0]
        image_rel_path = os.path.join('docs', 'images', f"{base_name}.png")
        
        source_abs_path = os.path.join(project_root, diagram_source_rel_path)
        image_abs_path = os.path.join(project_root, image_rel_path)

        if not os.path.exists(image_abs_path):
            print(f"    - {Colors.RED}MISSING:{Colors.RESET} {image_rel_path} (source: {diagram_source_rel_path})")
            all_up_to_date = False
            continue

        try:
            source_mtime = os.path.getmtime(source_abs_path)
            image_mtime = os.path.getmtime(image_abs_path)
            if source_mtime > image_mtime:
                print(f"    - {Colors.RED}OUTDATED:{Colors.RESET} {image_rel_path} (source: {diagram_source_rel_path})")
                all_up_to_date = False
        except FileNotFoundError:
             print(f"    - {Colors.YELLOW}WARNING: Source file not found for check: {diagram_source_rel_path}.{Colors.RESET}")
             all_up_to_date = False
    
    return all_up_to_date

def generate_toc(content):
    """Generates a Markdown Table of Contents from the headers in the content."""
    toc = []
    headers = re.findall(r'^(##+)\s+(.*)', content, re.MULTILINE)
    
    for level_str, title in headers:
        level = len(level_str) - 1 # h2 is level 1, h3 is level 2, etc.
        indent = "  " * (level - 1)
        
        # Create a URL-friendly anchor link
        slug = title.lower()
        slug = unicodedata.normalize('NFKD', slug).encode('ascii', 'ignore').decode('ascii')
        slug = re.sub(r'[^\w\s-]', '', slug).strip()
        slug = re.sub(r'[\s]+', '-', slug)
        
        toc.append(f"{indent}- [{title}](#{slug})")
        
    return "\n".join(toc)

def _get_diagram_paths(diagram_source_rel_path, template_path_str, project_root):
    """Calculates the correct relative paths for viewer and pandoc flavors."""
    base_name = os.path.splitext(os.path.basename(diagram_source_rel_path))[0]
    image_abs_path = os.path.join(project_root, 'docs', 'images', f"{base_name}.png")

    # For Pandoc, use an absolute file URI for maximum robustness.
    pandoc_image_path = pathlib.Path(image_abs_path).as_uri()

    # Viewer path is relative to the final generated Markdown file's location.
    final_md_path = pathlib.Path(str(template_path_str).replace('.template.md', '.md'))
    final_md_dir = final_md_path.parent
    viewer_image_path = os.path.relpath(image_abs_path, final_md_dir).replace(os.path.sep, '/')
    
    return viewer_image_path, pandoc_image_path

def process_markdown_content(content, project_root, template_path_str, flavor='viewer'):
    """
    Processes a string of markdown content, replacing custom placeholders for
    diagrams, figures, includes, page breaks, and table of contents.
    """
    # --- Function to render a single diagram's Markdown or return raw path/attrs ---
    # This will be called both by the main re.sub for {{diagram:}} and internally by {{grouped_figure:}}
    def _render_single_diagram(diagram_source_rel_path, attributes_str, current_flavor, raw_pandoc_info_only=False):
        viewer_image_path, pandoc_image_path = _get_diagram_paths(diagram_source_rel_path, template_path_str, project_root)

        attr_dict = {}
        if attributes_str:
            pairs = [p.strip() for p in attributes_str.split('|')]
            for pair in pairs:
                if '=' in pair:
                    key, value = pair.split('=', 1)
                    attr_dict[key.strip().lower()] = value.strip()

        # Generate a standard Pandoc attributes string (e.g., {width="50%"})
        pandoc_attr_parts = [f'{k}="{v}"' for k, v in attr_dict.items() if k != 'scale']
        pandoc_attributes_string = "{" + " ".join(pandoc_attr_parts) + "}" if pandoc_attr_parts else ""

        if raw_pandoc_info_only:
            return pandoc_image_path, pandoc_attributes_string

        if current_flavor == 'pandoc':
            # Generate clean, standard Markdown. Styling is now fully handled by the reference doc.
            return f"![]({pandoc_image_path}){pandoc_attributes_string}"
        else: # 'viewer' flavor
            html_attrs_parts = [f'{k}="{v}"' for k, v in attr_dict.items() if k != 'scale']
            html_attrs = " ".join(html_attrs_parts)
            return f'<div align="center">\n  <img src="{viewer_image_path}" {html_attrs.strip()}>\n</div>'

    # --- Process {{grouped_figure:...}} placeholders FIRST ---
    # {{grouped_figure:diagram_path|attr1=val1|caption=Caption Text}}
    def replace_grouped_figure_placeholder(match):
        current_flavor = flavor # Use the outer 'flavor'
        full_spec = match.group(1).strip()
        
        # Split by the first ' | caption=' to separate diagram_info from actual caption
        diagram_info_part, *caption_part_list = re.split(r'\s*\|\s*caption=', full_spec, 1)

        # Parse diagram info and attributes
        diagram_parts = [p.strip() for p in diagram_info_part.split('|')]
        diagram_source_rel_path = diagram_parts[0]
        
        attr_dict = {}
        for part in diagram_parts[1:]:
            if '=' in part:
                key, value = part.split('=', 1)
                attr_dict[key.strip().lower()] = value.strip()
        
        caption_text = caption_part_list[0] if caption_part_list else ""

        # Render the nested diagram using the helper function to get raw path and attributes.
        diagram_specific_attrs = '|'.join([f'{k}={v}' for k, v in attr_dict.items() if k not in ['caption']])
        
        # Call _render_single_diagram with the new flag to get path and attributes string.
        diagram_image_path, diagram_attributes_string = _render_single_diagram(diagram_source_rel_path, diagram_specific_attrs, current_flavor='pandoc', raw_pandoc_info_only=True)

        if current_flavor == 'pandoc':
            # Wrap the entire captioned figure in the custom-style div.
            return f'\n::: {{custom-style="CenteredImage"}}\n![{caption_text}]({diagram_image_path}){diagram_attributes_string}\n:::\n'
        else: # viewer flavor
            # For MD viewers, render as an HTML block for center alignment and clarity.
            html_attrs_parts = [f'{k}="{v}"' for k, v in attr_dict.items() if k not in ['scale', 'caption']]
            html_attrs = " ".join(html_attrs_parts)
            
            clean_caption = re.sub(r'^\s*#+\s*', '', caption_text, flags=re.MULTILINE)
            viewer_image_path, _ = _get_diagram_paths(diagram_source_rel_path, template_path_str, project_root)

            return f'<div align="center">\n  <p>{clean_caption}</p>\n  <img src="{viewer_image_path}" {html_attrs.strip()}>\n</div>'

    # Process grouped_figure FIRST to ensure its internal diagram is handled before main diagram re.sub
    content = re.sub(r'\{\{grouped_figure:(.*?)\}\}', 
                     replace_grouped_figure_placeholder, 
                     content, flags=re.DOTALL) # Ensure DOTALL is here

    # --- Process standalone {{diagram:...}} placeholders ---
    # These will only be processed if they are NOT inside a {{grouped_figure}}
    def replace_standalone_diagram_placeholder(match):
        return _render_single_diagram(match.group(1), match.group(2) or "", flavor)

    content = re.sub(r'\{\{diagram:(.*?)(?:\|(.*?))?\}\}', 
                     replace_standalone_diagram_placeholder, 
                     content)

    # --- Process {{include:...}} placeholders ---
    def replace_include_placeholder(match):
        include_rel_path = match.group(1)
        include_abs_path = os.path.join(project_root, include_rel_path)
        try:
            with open(include_abs_path, 'r', encoding='utf-8') as f:
                return f.read()
        except FileNotFoundError:
            return f"ERROR: Included file not found at '{include_rel_path}'"
            
    content = re.sub(r'\{\{include:(.*?)\}\}', replace_include_placeholder, content)

    # --- Process {{pagebreak}} placeholders ---
    # This generates a unique marker that can be found and replaced by a post-processor.
    def replace_pagebreak_placeholder(match):
        if flavor == 'pandoc':
            return '\n---PAGEBREAK---\n' # Unique marker for post-processing
        else:
            return ''

    content = re.sub(r'\{\{pagebreak\}\}', replace_pagebreak_placeholder, content)

    # --- Process {{toc}} placeholder ---
    if '{{toc}}' in content:
        toc_content = generate_toc(content)
        content = content.replace('{{toc}}', toc_content, 1)

    # --- Process [Date] placeholder ---
    if '[Date]' in content:
        current_date = datetime.now().strftime("%B %-d, %Y") if os.name != 'nt' else datetime.now().strftime("%B %#d, %Y")
        content = content.replace('[Date]', current_date)

    return content

def build_doc_content(project_root, template_path_str, flavor='viewer'):
    """
    Builds the content for a specific doc by processing its template.
    """
    with open(template_path_str, 'r', encoding='utf-8') as f:
        content = f.read()
    return process_markdown_content(content, project_root, template_path_str, flavor)

def render_all_diagrams(project_root, force_render=False, template_files=None):
    """
    Scans all specified template files for diagram placeholders, then renders
    or copies them as needed. Returns True on success.
    """
    if template_files is None:
        template_files = ['docs/FRAMEWORK_MANUAL.template.md']

    print(f"\n{Colors.BOLD}{Colors.CYAN}--- Processing Diagrams ---{Colors.RESET}")
    
    content_to_scan = ""
    for file_rel_path in template_files:
        # Resolve the full path to handle files in the root vs. subdirectories correctly.
        full_path = os.path.join(project_root, file_rel_path)
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                content_to_scan += f.read() + "\n"
        except FileNotFoundError:
            # Print the full path that was attempted for clear debugging.
            print(f"    - {Colors.YELLOW}WARNING: Template file for diagram scan not found: {full_path}{Colors.RESET}")

    content = content_to_scan
    images_dir = os.path.join(project_root, 'docs', 'images')
    os.makedirs(images_dir, exist_ok=True)
    
    diagrams_to_render = set() # Store (source_path, attributes_str) tuples to avoid duplicates

    # Find standalone {{diagram:...}} placeholders
    for placeholder in re.finditer(r'\{\{diagram:(.*?)(?:\|(.*?))?\}\}', content):
        diagram_source_rel_path = placeholder.group(1).strip()
        attributes_str = placeholder.group(2) or ""
        diagrams_to_render.add((diagram_source_rel_path, attributes_str))

    # Find diagrams inside {{grouped_figure:...}} placeholders
    # Need to parse the full spec to extract the diagram_source_rel_path and its attributes
    for placeholder in re.finditer(r'\{\{grouped_figure:(.*?)\}\}', content, flags=re.DOTALL):
        full_spec = placeholder.group(1).strip()
        
        # This parsing logic reuses the attribute extraction from build_readme_content
        diagram_info_part, *caption_part_list = re.split(r'\s*\|\s*caption=', full_spec, 1)
        diagram_parts = [p.strip() for p in diagram_info_part.split('|')]
        diagram_source_rel_path = diagram_parts[0]
        
        # Reconstruct attributes string from diagram_parts[1:] for rendering purposes
        attr_dict = {}
        for part in diagram_parts[1:]:
            if '=' in part:
                key, value = part.split('=', 1)
                attr_dict[key.strip().lower()] = value.strip()
        reconstructed_attributes_str = '|'.join([f'{k}={v}' for k,v in attr_dict.items()])

        diagrams_to_render.add((diagram_source_rel_path, reconstructed_attributes_str))
        
    all_diagrams_ok = True
    for diagram_source_rel_path, attributes_str in diagrams_to_render:
        base_name = os.path.splitext(os.path.basename(diagram_source_rel_path))[0]
        image_abs_path = os.path.join(project_root, 'docs', 'images', f"{base_name}.png")
        source_abs_path = os.path.join(project_root, diagram_source_rel_path)
        
        should_render = False
        if force_render:
            should_render = True
        elif not os.path.exists(image_abs_path):
            should_render = True
        else:
            try:
                source_mtime = os.path.getmtime(source_abs_path)
                image_mtime = os.path.getmtime(image_abs_path)
                if source_mtime > image_mtime:
                    should_render = True
                else:
                    print(f"    - Skipping {Colors.CYAN}{os.path.basename(diagram_source_rel_path)}{Colors.RESET} (up-to-date)")
            except FileNotFoundError:
                print(f"    - {Colors.YELLOW}WARNING: Source file not found for comparison: {diagram_source_rel_path}. Will attempt to render.{Colors.RESET}")
                # If source is missing, we must render or it'll fail later.
                should_render = True 

        if should_render:
            if diagram_source_rel_path.endswith('.mmd'):
                scale_match = re.search(r'scale=([\d\.]+)', attributes_str)
                scale = scale_match.group(1) if scale_match else '1.8'
                if not render_mermaid_diagram(source_abs_path, image_abs_path, project_root, scale=scale):
                    all_diagrams_ok = False
            elif diagram_source_rel_path.endswith('.txt'):
                font_size = 22 if 'replication_report_format' in diagram_source_rel_path else 20 if 'analysis_log_format' in diagram_source_rel_path else 36
                if not render_text_diagram(source_abs_path, image_abs_path, project_root, font_size=font_size):
                    all_diagrams_ok = False
            elif diagram_source_rel_path.endswith(('.png', '.jpg', '.jpeg')):
                print(f"    - Copying pre-generated image: {Colors.CYAN}{os.path.basename(diagram_source_rel_path)}{Colors.RESET}")
                try:
                    shutil.copy2(source_abs_path, image_abs_path) # copy2 preserves metadata like mtime
                except FileNotFoundError:
                    print(f"    - {Colors.RED}ERROR: Source image not found at {source_abs_path}{Colors.RESET}")
                    all_diagrams_ok = False
                except Exception as e:
                    print(f"    - {Colors.RED}ERROR: Failed to copy {os.path.basename(diagram_source_rel_path)}: {e}{Colors.RESET}")
                    all_diagrams_ok = False
            else:
                print(f"    - {Colors.YELLOW}WARNING: Unknown diagram type for {Colors.CYAN}{os.path.basename(diagram_source_rel_path)}{Colors.RESET}. Skipping processing.{Colors.RESET}")
    
    if not all_diagrams_ok:
        print(f"\n{Colors.RED}{Colors.BOLD}--- BUILD FAILED: One or more diagrams could not be rendered. ---{Colors.RESET}")
    
    return all_diagrams_ok

def convert_to_docx(pypandoc, output_docx_path, project_root, source_md_path):
    """Converts a markdown file to DOCX, with robust error handling."""
    output_filename = os.path.basename(output_docx_path)
    print(f"    - Converting '{Colors.CYAN}{os.path.basename(source_md_path)}{Colors.RESET}' to DOCX...")
    
    permission_error_printed = False
    while True:
        try:
            pandoc_args_base = ['--standalone']
            reference_docx_path = os.path.join(project_root, 'docs', 'custom_reference.docx')
            if os.path.exists(reference_docx_path):
                pandoc_args_base.append(f'--reference-doc={reference_docx_path}')

            input_format_with_extensions = 'markdown+yaml_metadata_block+latex_macros+raw_attribute'
            final_pandoc_extra_args = ['-f', input_format_with_extensions] + pandoc_args_base
            
            pypandoc.convert_file(
                source_md_path, 'docx', format='markdown',
                outputfile=output_docx_path,
                extra_args=final_pandoc_extra_args
            )
            
            if permission_error_printed:
                print(f"      {Colors.GREEN}File unlocked. Resuming...{Colors.RESET}")
            
            print(f"      {Colors.GREEN}Successfully built '{Colors.CYAN}{output_filename}{Colors.GREEN}'!{Colors.RESET}")

            docx_postprocessor.insert_page_breaks_by_marker(output_docx_path, '---PAGEBREAK---')
            return True

        except RuntimeError as e:
            if "permission denied" in str(e).lower():
                if not permission_error_printed:
                    print(f"      {Colors.YELLOW}[WAITING] Could not write to '{output_filename}'.")
                    print(f"      The file is likely open in another program.")
                    print(f"      Please close the file. The script will retry automatically... (Ctrl+C to cancel){Colors.RESET}")
                    permission_error_printed = True
                time.sleep(2)
                continue
            else:
                print(f"\n{Colors.RED}[ERROR] An unexpected error occurred with Pandoc.{Colors.RESET}")
                raise e
        except FileNotFoundError:
            print(f"{Colors.RED}\n[ERROR] `pandoc` command not found. See: https://pandoc.org/installing.html{Colors.RESET}")
            return False
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Build cancelled by user.{Colors.RESET}")
            return False


def is_doc_up_to_date(project_root, final_md_path_str, template_path_str):
    """Checks if a final .md file is newer than its template and all its generated diagram images."""
    if not os.path.exists(final_md_path_str) or not os.path.exists(template_path_str):
        return False
    
    try:
        final_mtime = os.path.getmtime(final_md_path_str)
        if os.path.getmtime(template_path_str) > final_mtime:
            return False

        # Check if the document contains a [Date] placeholder
        with open(template_path_str, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # If the template contains a [Date] placeholder, we need to check if the document was built today
        if '[Date]' in content:
            # Get the current date
            current_date = datetime.now().strftime("%B %-d, %Y") if os.name != 'nt' else datetime.now().strftime("%B %#d, %Y")
            # Check if the document contains today's date
            with open(final_md_path_str, 'r', encoding='utf-8') as f:
                final_content = f.read()
            if current_date not in final_content:
                return False

        # Regex to find any placeholder that points to a source file for a diagram/image.
        placeholder_regex = r'\{\{(?:diagram|grouped_figure):(.+?)(?:\||\})'
        for match in re.finditer(placeholder_regex, content):
            source_file_rel_path = match.group(1).strip()
            base_name = os.path.splitext(os.path.basename(source_file_rel_path))[0]
            image_path = os.path.join(project_root, 'docs', 'images', f"{base_name}.png")
            
            if os.path.exists(image_path) and os.path.getmtime(image_path) > final_mtime:
                return False
        
        return True
    except (OSError, FileNotFoundError):
        return False

def main():
    parser = argparse.ArgumentParser(description="Builds project documentation from templates.")
    parser.add_argument('--check', action='store_true', help="Check if docs are up-to-date without modifying files.")
    parser.add_argument('--force', action='store_true', help="Force regeneration of all diagrams and documents.")
    parser.add_argument('--force-diagrams', action='store_true', help="Force regeneration of all diagrams.")
    parser.add_argument('--force-documents', action='store_true', help="Force regeneration of all markdown and docx documents.")
    args = parser.parse_args()
    
    project_root = pathlib.Path(__file__).resolve().parent.parent.parent
    
    # Determine which stages to force
    do_force_diagrams = args.force or args.force_diagrams
    do_force_documents = args.force or args.force_documents
    
    if args.check:
        print(f"{Colors.BOLD}{Colors.CYAN}--- Checking if documentation is up-to-date... ---{Colors.RESET}")

        docs_to_check = [
            ('README.template.md', 'README.md'),
            ('DEVELOPERS_GUIDE.template.md', 'DEVELOPERS_GUIDE.md'),
            ('docs/DATA_PREPARATION_DATA_DICTIONARY.template.md', 'docs/DATA_PREPARATION_DATA_DICTIONARY.md'),
            ('docs/EXPERIMENT_WORKFLOW_DATA_DICTIONARY.template.md', 'docs/EXPERIMENT_WORKFLOW_DATA_DICTIONARY.md'),
            ('docs/FRAMEWORK_MANUAL.template.md', 'docs/FRAMEWORK_MANUAL.md'),
            ('docs/PROJECT_ROADMAP.md', 'docs/PROJECT_ROADMAP.md'),
            ('docs/article_main_text.template.md', 'docs/article_main_text.md'),
            ('docs/REPLICATION_GUIDE.template.md', 'docs/REPLICATION_GUIDE.md'),
            ('docs/TESTING_GUIDE.template.md', 'docs/TESTING_GUIDE.md')
        ]
        
        # 1. Check diagrams from all templates
        all_template_paths = [item[0] for item in docs_to_check]
        diagrams_ok = check_diagrams_are_up_to_date(project_root, all_template_paths)

        # 2. Check content of final markdown files
        all_content_ok = True
        for template_rel_path, final_rel_path in docs_to_check:
            # If the source and destination are the same, it's a simple MD file, not a template.
            # Skip the content check for these files.
            if template_rel_path == final_rel_path:
                continue

            template_path = os.path.join(project_root, template_rel_path)
            final_path = os.path.join(project_root, final_rel_path)
            
            if not os.path.exists(template_path):
                continue

            # This logic must perfectly mirror the build process.
            # First, build the body content.
            viewer_content = build_doc_content(project_root, template_path, flavor='viewer')
            # Then, generate the corresponding warning header.
            header = generate_warning_header(final_rel_path, f"/{template_rel_path}")
            # The final expected content is the combination of both.
            expected_content = header + '\n' + viewer_content
            
            
            try:
                with open(final_path, 'r', encoding='utf-8') as f:
                    current_content = f.read()
            except FileNotFoundError:
                print(f"    - {Colors.RED}MISSING:{Colors.RESET} {final_rel_path}")
                all_content_ok = False
                continue

            # Normalize line endings for a robust comparison before the final check.
            normalized_current = current_content.replace('\r\n', '\n')
            normalized_expected = expected_content.replace('\r\n', '\n')
            
            # Get the current date for comparison
            current_date = datetime.now().strftime("%B %-d, %Y") if os.name != 'nt' else datetime.now().strftime("%B %#d, %Y")
            
            # Replace the date in both current and expected content for comparison
            # Handle both date: "..." YAML format and inline [Date] placeholders
            normalized_current = re.sub(r'date: "[^"]+"', 'date: "[DATE_PLACEHOLDER]"', normalized_current)
            normalized_current = normalized_current.replace(current_date, '[DATE_PLACEHOLDER]')
            normalized_current = re.sub(r'\[Date\]', '[DATE_PLACEHOLDER]', normalized_current)
            normalized_expected = re.sub(r'date: "[^"]+"', 'date: "[DATE_PLACEHOLDER]"', normalized_expected)
            normalized_expected = normalized_expected.replace(current_date, '[DATE_PLACEHOLDER]')
            normalized_expected = normalized_expected.replace('[Date]', '[DATE_PLACEHOLDER]')
            

            if normalized_current != normalized_expected:
                print(f"    - {Colors.RED}OUTDATED:{Colors.RESET} {final_rel_path} content does not match template.")
                all_content_ok = False

        if diagrams_ok and all_content_ok:
            print(f"{Colors.GREEN}Documentation is up-to-date.{Colors.RESET}")
            sys.exit(0)
        else:
            print(f"\n{Colors.RED}Documentation is out of date. Please run 'pdm run build-docs' and commit the changes.{Colors.RESET}")
            sys.exit(1)

    # Define which files have placeholders that might contain diagrams
    files_with_diagrams = [
        'README.template.md',
        'DEVELOPERS_GUIDE.template.md',
        'docs/DATA_PREPARATION_DATA_DICTIONARY.template.md',
        'docs/EXPERIMENT_WORKFLOW_DATA_DICTIONARY.template.md',
        'docs/FRAMEWORK_MANUAL.template.md',
        'docs/PROJECT_ROADMAP.md',
        'docs/article_main_text.template.md',
        'docs/REPLICATION_GUIDE.template.md',
        'docs/TESTING_GUIDE.template.md'
    ]
    if not render_all_diagrams(project_root, force_render=do_force_diagrams, template_files=files_with_diagrams):
        sys.exit(1)

    # Centralized document definitions
    # For templates: (template_path, final_path, display_name)
    documents_to_build = [
        ('README.template.md', 'README.md', 'README.md'),
        ('DEVELOPERS_GUIDE.template.md', 'DEVELOPERS_GUIDE.md', 'DEVELOPERS_GUIDE.md'),
        ('docs/FRAMEWORK_MANUAL.template.md', 'docs/FRAMEWORK_MANUAL.md', 'FRAMEWORK_MANUAL.md'),
        ('docs/article_main_text.template.md', 'docs/article_main_text.md', 'article_main_text.md'),
        ('docs/REPLICATION_GUIDE.template.md', 'docs/REPLICATION_GUIDE.md', 'REPLICATION_GUIDE.md'),
        ('docs/DATA_PREPARATION_DATA_DICTIONARY.template.md', 'docs/DATA_PREPARATION_DATA_DICTIONARY.md', 'DATA_PREPARATION_DATA_DICTIONARY.md'),
        ('docs/EXPERIMENT_WORKFLOW_DATA_DICTIONARY.template.md', 'docs/EXPERIMENT_WORKFLOW_DATA_DICTIONARY.md', 'EXPERIMENT_WORKFLOW_DATA_DICTIONARY.md'),
        ('docs/TESTING_GUIDE.template.md', 'docs/TESTING_GUIDE.md', 'TESTING_GUIDE.md'),
    ]
    
    # Non-template MD files that should also have DOCX versions
    standalone_md_files = [
        'LICENSE.md',
        'CHANGELOG.md',
        'docs/changelog_template.md',
        'docs/article_cover_letter.md',
        'docs/PROJECT_ROADMAP.md',
        'output/project_reports/project_scope_report.md',
        'output/project_reports/SYNC_MANIFEST.md',
    ]

    print(f"\n{Colors.BOLD}{Colors.CYAN}--- Building Final Markdown Files from Templates ---{Colors.RESET}")

    # Track which MD files were rebuilt so we can force their DOCX conversions
    rebuilt_md_files = set()

    def build_single_document(template_rel_path, final_rel_path, display_name):
        """Helper function to build a single document from its template."""
        template_path = os.path.join(project_root, template_rel_path)
        final_path = os.path.join(project_root, final_rel_path)
        
        if not do_force_documents and is_doc_up_to_date(project_root, final_path, template_path):
            print(f"    - Skipping {Colors.CYAN}{display_name}{Colors.RESET} build (up-to-date).")
            return False
        else:
            viewer_content = build_doc_content(project_root, template_path, flavor='viewer')
            header = generate_warning_header(final_rel_path, f'/{template_rel_path}')
            final_content = header + '\n' + viewer_content
            
            make_writable(final_path)
            with open(final_path, 'w', encoding='utf-8') as f:
                f.write(final_content)
            make_readonly(final_path)
            print(f"    - {Colors.GREEN}Successfully built {display_name}!{Colors.RESET}")
            return True

    # Build all documents
    for template_rel, final_rel, display in documents_to_build:
        if build_single_document(template_rel, final_rel, display):
            rebuilt_md_files.add(str(pathlib.Path(os.path.join(project_root, final_rel)).resolve()))

    # Handle PROJECT_ROADMAP.md separately (not a template)
    roadmap_final_path = os.path.join(project_root, 'docs/PROJECT_ROADMAP.md')
    if os.path.exists(roadmap_final_path):
        print(f"    - Skipping {Colors.CYAN}PROJECT_ROADMAP.md{Colors.RESET} build (up-to-date).")
    else:
        print(f"    - {Colors.GREEN}Verified PROJECT_ROADMAP.md exists for DOCX conversion.{Colors.RESET}")

    print(f"\n{Colors.BOLD}{Colors.CYAN}--- Converting all Markdown files to DOCX ---{Colors.RESET}")
    try:
        import pypandoc
        word_docs_dir = os.path.join(project_root, 'docs', 'word_docs')
        os.makedirs(word_docs_dir, exist_ok=True)
        
        # List of final markdown files that were built from templates.
        # These need special handling for DOCX conversion to use pandoc-flavored placeholders.
        files_needing_placeholders = {
            str(pathlib.Path(os.path.join(project_root, 'README.md')).resolve()),
            str(pathlib.Path(os.path.join(project_root, 'docs/FRAMEWORK_MANUAL.md')).resolve()),
            str(pathlib.Path(os.path.join(project_root, 'docs/REPLICATION_GUIDE.md')).resolve()),
            str(pathlib.Path(os.path.join(project_root, 'docs/TESTING_GUIDE.md')).resolve()),
        }
        
        # Combine all MD files for DOCX conversion: built templates + standalone files
        md_files_to_convert = [final_path for _, final_path, _ in documents_to_build] + standalone_md_files
        
        # Use a context manager for robust cleanup of temporary files
        with tempfile.TemporaryDirectory() as temp_dir:
            for md_rel_path in md_files_to_convert:
                source_path = pathlib.Path(project_root) / md_rel_path
                
                # Skip if source doesn't exist
                if not source_path.exists():
                    continue
                
                # Skip template files
                if source_path.name.endswith('.template.md'):
                    continue

                output_filename = source_path.with_suffix(".docx").name
                
                output_path = os.path.join(word_docs_dir, output_filename)
                
                should_build = False
                resolved_source = str(source_path.resolve())
                if do_force_documents or not os.path.exists(output_path) or resolved_source in rebuilt_md_files:
                    should_build = True
                elif os.path.exists(output_path):
                    source_mtime = os.path.getmtime(source_path)
                    docx_mtime = os.path.getmtime(output_path)
                    
                    # 1. Check if the source MD file is newer
                    if source_mtime >= docx_mtime:
                        should_build = True
                    
                    # 2. Check if the reference DOCX template is newer
                    reference_docx_path = os.path.join(project_root, 'docs', 'custom_reference.docx')
                    if not should_build and os.path.exists(reference_docx_path):
                        ref_mtime = os.path.getmtime(reference_docx_path)
                        if ref_mtime > docx_mtime:
                            print(f"      - Stale: '{os.path.basename(output_path)}' is older than the reference style template.")
                            should_build = True

                    # 3. Also check if any diagram images referenced in the MD are newer
                    if not should_build:
                        try:
                            with open(source_path, 'r', encoding='utf-8') as f:
                                md_content = f.read()
                            
                            placeholder_regex = r'\{\{(?:diagram|grouped_figure):(.+?)(?:\||\})'
                            for match in re.finditer(placeholder_regex, md_content):
                                diagram_source_rel_path = match.group(1).strip()
                                base_name = os.path.splitext(os.path.basename(diagram_source_rel_path))[0]
                                image_path = os.path.join(project_root, 'docs', 'images', f"{base_name}.png")
                                
                                if os.path.exists(image_path) and os.path.getmtime(image_path) > docx_mtime:
                                    should_build = True
                                    break
                        except (OSError, FileNotFoundError):
                            should_build = True

                if not should_build:
                    print(f"    - Skipping DOCX conversion for {Colors.CYAN}{output_filename}{Colors.RESET} (up-to-date).")
                    continue
                
                # Check if this MD file was generated from a template
                template_path = pathlib.Path(str(source_path).replace('.md', '.template.md'))
                path_to_convert = str(source_path)

                # If a template exists, we must re-process it with pandoc flavor to ensure
                # metadata and figures are correctly formatted for DOCX conversion.
                if template_path.exists():
                    pandoc_flavored_content = build_doc_content(project_root, str(template_path), flavor='pandoc')
                    
                    # Write the processed content to a temporary file for reliable conversion.
                    temp_md_path = os.path.join(temp_dir, source_path.name)
                    with open(temp_md_path, 'w', encoding='utf-8') as f:
                        f.write(pandoc_flavored_content)
                    path_to_convert = temp_md_path
                
                if not convert_to_docx(pypandoc, output_path, project_root, source_md_path=path_to_convert):
                    sys.exit(1)
        
        print(f"\n{Colors.GREEN}{Colors.BOLD}All documents built successfully.\n{Colors.RESET}")

    except ImportError:
        print(f"{Colors.YELLOW}--- DEPENDENCY WARNING: 'pypandoc' not found. Skipping DOCX generation. ---{Colors.RESET}")

if __name__ == "__main__":
    main()

# === End of scripts/build/build_docs.py ===
