#!/usr/bin/env python3
#-*- coding: utf-8 -*-
#
# Personality Matching Experiment Framework
# Copyright (C) 2025 [Your Name/Institution]
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# Filename: scripts/extract_assembly_logic_text.py

"""
Extracts and assembles assembly logic text from raw Solar Fire reports.

This utility script is a key part of the assembly logic validation workflow.
It takes the raw, multi-section interpretation reports generated by Solar Fire
and programmatically extracts only the specific delineation components used by
our main assembly algorithm.

It correctly parses the complex file format, isolates the required text
snippets, and assembles them into the final, clean, tab-delimited
`personalities_db.gold_standard.txt` file, which serves as the "ground truth"
for our automated `pytest` verification.
"""

import argparse
import csv
import logging
import sys
from pathlib import Path

from colorama import Fore
from tqdm import tqdm

# No src imports are needed for this simple script.


logging.basicConfig(level=logging.INFO, format="%(message)s")


import re

def extract_subject_info(content):
    """Extracts the subject's name and birth year from the report header."""
    name_match = re.search(r"(.+?) - Natal Chart", content)
    name = name_match.group(1).strip() if name_match else "Unknown"
    year_match = re.search(r"\b(\d{4})\b", content)
    birth_year = year_match.group(1) if year_match else "Unknown"
    return name, birth_year


import shutil

def main():
    """Main function to extract and assemble the assembly logic text."""
    parser = argparse.ArgumentParser(
        description="Extract and assemble assembly logic delineations."
    )
    # This script now operates entirely within the sandbox and needs no arguments.
    args = parser.parse_args()

    print(f"\n{Fore.YELLOW}--- Assembling Assembly Logic Delineations ---{Fore.RESET}")

    sandbox_dir = Path("temp_assembly_logic_validation")
    if not sandbox_dir.exists():
        logging.error(f"Sandbox directory not found at '{sandbox_dir}'. Please run the previous scripts first.")
        sys.exit(1)

    # Define paths inside the sandbox
    raw_reports_dir = sandbox_dir / "data/intermediate/assembly_logic_raw_reports"
    subject_db_path = sandbox_dir / "data/processed/subject_db.assembly_logic.csv"
    output_path = sandbox_dir / "personalities_db.assembly_logic.txt"
    if not raw_reports_dir.exists():
        logging.error(f"Raw reports directory not found: {raw_reports_dir}")
        sys.exit(1)

    # --- Load subject DB to get the correct Index and idADB for each subject ---
    try:
        with open(subject_db_path, "r", encoding="utf-8") as f:
            subject_info_map = {
                row["Name"]: {"Index": row["Index"], "idADB": row["idADB"]}
                for row in csv.DictReader(f)
            }
    except FileNotFoundError:
        logging.error(f"Assembly logic subject DB not found at: {subject_db_path}")
        sys.exit(1)

    report_files = list(raw_reports_dir.glob("*.txt"))
    print(f"Processing {len(report_files)} raw report files from '{raw_reports_dir}'...")
    final_records = []
    for report_file in tqdm(
        sorted(report_files), desc="Extracting Text", ncols=80
    ):
        content = report_file.read_text(encoding="utf-8", errors="ignore")
        name, birth_year = extract_subject_info(content)

        if name not in subject_info_map:
            logging.warning(f"Could not find '{name}' in the assembly logic subject DB. Skipping.")
            continue

        # --- Extract relevant sections using a simple line-by-line parser ---
        lines = content.splitlines()
        desc_parts = []
        capturing = False
        
        headers_to_capture = [
            "BALANCE OF SIGNS", "BALANCE OF ELEMENTS", "BALANCE OF MODES",
            "BALANCE OF QUADRANTS", "BALANCE OF HEMISPHERES", "CHART POINTS"
        ]
        headers_to_stop_at = ["LUNAR PHASE", "CHART DETAILS", "BACKGROUND INFORMATION"]

        for line in lines:
            stripped_line = line.strip()

            if any(header in stripped_line for header in headers_to_stop_at + headers_to_capture):
                capturing = stripped_line in headers_to_capture

            elif capturing and stripped_line:
                # Ignore irrelevant lines within the sections
                if stripped_line.startswith("Scores:") or stripped_line.isupper():
                    continue
                desc_parts.append(stripped_line)

        full_desc = " ".join(desc_parts).strip()
        subject_info = subject_info_map[name]
        final_records.append(
            {
                "Index": subject_info["Index"],
                "idADB": subject_info["idADB"],
                "Name": name,
                "BirthYear": birth_year,
                "DescriptionText": full_desc,
            }
        )
        
    # Sort the final records by Index to ensure a consistent order
    final_records.sort(key=lambda x: int(x["Index"]))

    # --- Write the final output file ---
    try:
        with open(output_path, "w", encoding="utf-8", newline="") as f:
            writer = csv.DictWriter(
                f,
                fieldnames=["Index", "idADB", "Name", "BirthYear", "DescriptionText"],
                delimiter="\t",
            )
            writer.writeheader()
            writer.writerows(final_records)
        print(f"\n{Fore.YELLOW}--- Final Output ---{Fore.RESET}")
        print(f"{Fore.CYAN} - Assembly logic database saved to: {output_path}{Fore.RESET}")
        key_metric = f"Processed {len(final_records)} subjects"
        print(
            f"\n{Fore.GREEN}SUCCESS: {key_metric}. Assembly logic database "
            f"created successfully.{Fore.RESET}\n"
        )
    except IOError as e:
        logging.error(f"Failed to write output file: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()

# === End of scripts/extract_assembly_logic_text.py ===
