# Filename: tests/test_run_batch.py

import unittest
from unittest.mock import patch, MagicMock
import os
import sys
import shutil
import tempfile
import configparser
import importlib # Needed for importlib.import_module

# Ensure the real 'src' directory is in sys.path for imports.
# This should ideally be handled globally by tests/conftest.py.
# Keeping it here for robustness in case conftest.py is not yet fully configured or present.
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
src_path = os.path.join(project_root, 'src')
if src_path not in sys.path:
    sys.path.insert(0, src_path)

# IMPORTANT: DO NOT import config_loader or run_batch here at the top level.
# Their import will be carefully managed within setUp to ensure mocks are applied correctly.

class TestRunBatch(unittest.TestCase):

    def setUp(self):
        """
        Set up a temporary environment and aggressively mock config_loader and run_batch modules.
        This ensures our mocked configuration is used when run_batch is imported.
        """
        self.temp_dir_obj = tempfile.TemporaryDirectory(prefix="run_batch_test_")
        self.temp_dir = self.temp_dir_obj.name
        self.output_dir = os.path.join(self.temp_dir, "output")
        os.makedirs(self.output_dir)

        # Define the mock configuration data
        self.mock_config_data = {
            "Study": {
                "num_replications": "2", # This is the value we want to ensure is used
                "starting_replication_num": "1",
                "starting_base_seed": "1000",
                "starting_qgen_base_seed": "1500",
                "seed_increment": "1000",
                "qgen_seed_increment": "1000"
            },
            "General": {
                "base_output_dir": self.output_dir # Point to our temp output dir
            }
        }

        # Create a mock ConfigParser object from our mock data
        mock_cp = configparser.ConfigParser()
        for section, options in self.mock_config_data.items():
            mock_cp[section] = options

        # --- Aggressive Mocking of config_loader module ---
        # 1. Create a MagicMock object that will act as our config_loader module.
        self._mock_config_loader_module = MagicMock()

        # 2. Set the APP_CONFIG attribute on the mock module.
        # This is what run_batch.py will see as config_loader.APP_CONFIG
        self._mock_config_loader_module.APP_CONFIG = mock_cp

        # 3. Define the side_effect for get_config_value on the mock module.
        # This handles cases where config_loader.get_config_value is called.
        def mock_get_value_side_effect(config_obj_ignored, section, key, fallback=None, value_type=str):
            if section in self.mock_config_data and key in self.mock_config_data[section]:
                value = self.mock_config_data[section][key]
                if value_type is int:
                    return int(value)
                return value
            return fallback
        self._mock_config_loader_module.get_config_value.side_effect = mock_get_value_side_effect

        # 4. Store original modules from sys.modules if they exist, then replace them.
        # This is crucial for isolating tests and preventing side effects.
        self._original_sys_modules_config_loader = sys.modules.get('config_loader')
        self._original_sys_modules_run_batch = sys.modules.get('run_batch')

        # Replace the 'config_loader' entry in sys.modules with our mock.
        sys.modules['config_loader'] = self._mock_config_loader_module

        # 5. Ensure 'run_batch' is removed from sys.modules if it was previously imported.
        # This forces a fresh import of run_batch in the next step, which will then
        # import our mocked config_loader.
        if 'run_batch' in sys.modules:
            del sys.modules['run_batch']

        # 6. Now, import run_batch. It will now import the mocked config_loader.
        # We store the imported module as an instance attribute for use in the test method.
        self.run_batch_module = importlib.import_module("run_batch")


    def tearDown(self):
        """Clean up temporary directory and restore original modules to sys.modules."""
        self.temp_dir_obj.cleanup()

        # Restore original config_loader module in sys.modules
        if self._original_sys_modules_config_loader is not None:
            sys.modules['config_loader'] = self._original_sys_modules_config_loader
        elif 'config_loader' in sys.modules:
            # If it was imported by a test and didn't exist before, remove it
            del sys.modules['config_loader']

        # Restore original run_batch module in sys.modules
        if self._original_sys_modules_run_batch is not None:
            sys.modules['run_batch'] = self._original_sys_modules_run_batch
        elif 'run_batch' in sys.modules:
            del sys.modules['run_batch']


    @patch('run_batch.subprocess.run') # This patch is still needed for subprocess.run calls
    def test_run_batch_happy_path(self, mock_subprocess_run):
        """
        Tests that run_batch.py reads config, loops correctly, and calls
        all required downstream scripts with the correct arguments.
        """
        # Arrange: Mock a successful subprocess run for all calls
        mock_subprocess_run.return_value = MagicMock(returncode=0)

        # Act: Run the main function of run_batch.py
        # Use the module imported/managed in setUp, which now uses our mocked config.
        self.run_batch_module.main()

        # Assert: Check the calls to subprocess.run
        # Expected calls: 2 for orchestrate, 1 for retry, 1 for verify, 1 for rebuild_log, 1 for compile
        self.assertEqual(mock_subprocess_run.call_count, 6)

        calls = mock_subprocess_run.call_args_list

        # --- Assert Replication 1 Call ---
        cmd1 = calls[0].args[0]
        self.assertIn("orchestrate_experiment.py", cmd1[1])
        self.assertIn("--replication_num", cmd1)
        self.assertEqual(cmd1[cmd1.index("--replication_num") + 1], "1")
        self.assertIn("--base_seed", cmd1)
        self.assertEqual(cmd1[cmd1.index("--base_seed") + 1], "1000")
        self.assertIn("--qgen_base_seed", cmd1)
        self.assertEqual(cmd1[cmd1.index("--qgen_base_seed") + 1], "1500")

        # --- Assert Replication 2 Call ---
        cmd2 = calls[1].args[0]
        self.assertIn("orchestrate_experiment.py", cmd2[1])
        self.assertIn("--replication_num", cmd2)
        self.assertEqual(cmd2[cmd2.index("--replication_num") + 1], "2")
        self.assertIn("--base_seed", cmd2)
        self.assertEqual(cmd2[cmd2.index("--base_seed") + 1], "2000")
        self.assertIn("--qgen_base_seed", cmd2)
        self.assertEqual(cmd2[cmd2.index("--qgen_base_seed") + 1], "2500")

        # --- Assert Retry Script Call ---
        cmd3 = calls[2].args[0]
        self.assertIn("retry_failed_sessions.py", cmd3[1])
        self.assertEqual(cmd3[2], self.output_dir)

        # --- Assert Verify Script Call ---
        cmd4 = calls[3].args[0]
        self.assertIn("verify_pipeline_completeness.py", cmd4[1])
        self.assertEqual(cmd4[2], "--parent_dir")
        self.assertEqual(cmd4[3], self.output_dir)

        # --- Assert Rebuild Batch Log Script Call ---
        cmd5 = calls[4].args[0]
        self.assertIn("rebuild_batch_log.py", cmd5[1])
        self.assertEqual(cmd5[2], self.output_dir)

        # --- Assert Compile Script Call ---
        cmd6 = calls[5].args[0]
        self.assertIn("compile_results.py", cmd6[1])
        self.assertEqual(cmd6[2], self.output_dir)

if __name__ == '__main__':
    unittest.main(verbosity=2)